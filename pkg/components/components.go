package components

import (
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
)

// Component Details

// Component is the base type for all hardware.  It represents nodes, BMCs, Switches, etc... and can be extended to represnt other items as well.
// The UID field is a UUID that is generated by the system.
// The ID field is more commonly referred to as the Xname which uniquely identifies components and describes their location in the system.
// The official xname decoder ring is at https://cray-hpe.github.io/docs-csm/en-14/operations/component_names_xnames/
type Component struct {
	Uid                 uuid.UUID `json:"uid" db:"uid"`
	Id                  string    `json:"xname" db:"xname"`
	Type                string    `json:"type" db:"type"`
	State               string    `json:"state,omitempty" db:"state"`
	Flag                string    `json:"flag,omitempty" db:"flag"`
	Enabled             bool      `json:"enabled,omitempty" db:"enabled"`
	SwStatus            string    `json:"sw_status,omitempty" db:"sw_status"`
	Role                string    `json:"role,omitempty" db:"role"`
	SubRole             string    `json:"sub_role,omitempty" db:"subrole"`
	NID                 uint      `json:"nid,omitempty" db:"nid"`
	Subtype             string    `json:"sub_type,omitempty" db:"subtype"`
	NetType             string    `json:"net_type,omitempty" db:"net_type"`
	Arch                string    `json:"arch,omitempty" db:"arch"`
	Class               string    `json:"class,omitempty" db:"class"`
	ReservationDisabled bool      `json:"reservation_disabled,omitempty" db:"reservation_disabled"`
	Locked              bool      `json:"locked,omitempty" db:"locked"`
}

type ComponentDatabase interface {
	InsertComponent(component *Component) (string, error)
	UpdateComponent(component *Component) error
	DeleteComponent(id string) error
	GetComponent(id string) (*Component, error)
}

// Component Class describes the three types of cabinets that HPE ships.  We store them in all lowercase.
var validComponentClasses = [...]string{
	"river",
	"mountain",
	"hill",
}

// Component Arch describes the architecture of the component.  This should align with what uname -m returns. We store them in all lowercase.
var validComponentArchs = [...]string{
	"x86",
	"x86_64",
	"arm",
	"arm64",
	"aarch64",
}

// Component NetType describes the network type of the component.  We store them in all lowercase.
var validComponentNetTypes = [...]string{
	"ethernet",
	"infiniband",
	"oem",
	"slingshot",
	"none",
}

// Component Roles describe the role of a computer in the system.  Subroles are used to differentiate betweent the types of management nodes
var validComponentRoles = [...]string{
	"compute",
	"storage",
	"service",
	"system",
	"application",
	"management",
}

// Component Flags indicate a state of the component.  We store them in all lowercase.
var validFlagValues = [...]string{
	"unknown",
	"ok",
	"warning",
	"alert",
	"locked",
}

func (c *Component) Validate() error {
	// Validate the component class
	if !stringInSlice(c.Class, validComponentClasses[:]) {
		return fmt.Errorf("invalid component class %s", c.Class)
	}

	// Validate the component arch
	if !stringInSlice(c.Arch, validComponentArchs[:]) {
		return fmt.Errorf("invalid component arch %s", c.Arch)
	}

	// Validate the component net type
	if !stringInSlice(c.NetType, validComponentNetTypes[:]) {
		return fmt.Errorf("invalid component net type %s", c.NetType)
	}

	// Validate the component role
	if !stringInSlice(c.Role, validComponentRoles[:]) {
		return fmt.Errorf("invalid component role %s", c.Role)
	}

	// Validate the component flag
	if !stringInSlice(c.Flag, validFlagValues[:]) {
		return fmt.Errorf("invalid component flag %s", c.Flag)
	}

	return nil
}

// --  JSON Conversion for Component --
// Method to convert JSON to struct
func FromJSON(jsonData []byte) (*Component, error) {
	component := &Component{}
	err := json.Unmarshal(jsonData, component)
	if err != nil {
		return nil, err
	}
	if err := component.Validate(); err != nil {
		return nil, err
	}
	return component, nil
}

// Method to convert struct to JSON
func (c *Component) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(c)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

// Method to convert struct to JSON
func ToJSON(component *Component) ([]byte, error) {
	jsonData, err := json.Marshal(component)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

// Golang doesn't support generics, so we have to write our own stringInSlice function
func stringInSlice(str string, list []string) bool {
	for _, v := range list {
		if v == str {
			return true
		}
	}
	return false
}
